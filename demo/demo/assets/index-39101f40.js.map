{"version":3,"file":"index-39101f40.js","sources":["../../src/UI/NumberInput/utils.ts","../../src/UI/NumberInput/constants.ts","../../src/UI/NumberInput/index.tsx"],"sourcesContent":["import type { ComplementMode } from './types'\n\nexport const NOT_ALLOWED_NUM_CHARS_REGEX = /[^0-9.-]/g\n\nconst complementMinusOrEmpty = (val: string): string => {\n  return val === '-'\n    ? '-0'\n    : val === ''\n      ? '0'\n      : val\n}\n\n/**\n * @param val - formatted number value (with thousand separators). '-' is also a valid option\n * @returns value with trimmed decimal zeros to the closest valid number\n */\nexport const trimDecimalZeros = (val?: string | null): string => {\n  if (val == null || val === '' || val === '-') {\n    return ''\n  }\n\n  const [integerPart = '', decimalPart = ''] = val.toString().split('.')\n\n  if (decimalPart === '') {\n    return integerPart\n  }\n\n  return `${complementMinusOrEmpty(integerPart)}.${decimalPart.replace(/0+$/, '')}`\n}\n\nexport const padZeros = (val: string | number, decimalPrecision: number = 0): string => {\n  if (decimalPrecision < 1) {\n    return val.toString()\n  }\n\n  const [integerPart = '', decimalPart = ''] = val.toString().split('.')\n  val = `${complementMinusOrEmpty(integerPart)}.${decimalPart.slice(0, decimalPrecision)}`\n\n  const zerosToAdd = Math.max(0, decimalPrecision - decimalPart.length)\n  return `${val}${'0'.repeat(zerosToAdd)}`\n}\n\nexport const findNthNumCharIndex = (val: string, n: number): number => {\n  if (n < 1) {\n    return -1\n  }\n\n  if (n > val.length) {\n    return val.length - 1\n  }\n\n  let digitCount = 0\n\n  for (let i = 0; i < val.length; i++) {\n    const isCharNotAllowed = NOT_ALLOWED_NUM_CHARS_REGEX.test(val[i])\n\n    if (!isCharNotAllowed) {\n      digitCount++\n\n      if (digitCount === n) {\n        return i\n      }\n    }\n  }\n\n  return -1\n}\n\nexport const isEmptyString = (val?: string | null): boolean => val == null || val === ''\n\nexport const isInvalidNumberString = (val?: string | null): boolean => isEmptyString(val) || isNaN(Number(val))\n\nexport const extractLeadingZerosAfterDot = (str: string): string => {\n  const fractionalPart = str.split('.')[1] ?? ''\n  return fractionalPart.match(/^0+/)?.[0] ?? ''\n}\n\nexport const trimEndingZeros = (value: string): string => {\n  return value.replace(/^0+(?=\\d)/, '')\n}\n\nexport const trimStartingZeros = (value: string): string => {\n  return value.replace(/^(-)?0*(?=\\d)/, '$1')\n}\n\nexport const getDecimalPartTrimmedWithDot = (value: string, decimalPrecision: number): string => {\n  const decimalPart = value.split('.')[1] ?? ''\n  const dotPart = value.includes('.') ? '.' : ''\n  const trimmedDecimals = decimalPart.slice(0, decimalPrecision)\n  return `${dotPart}${trimmedDecimals}`\n}\n\nexport const applyComplement = (value: string, mode: ComplementMode, decimalPrecision: number): string => {\n  const precision = mode === 'max-scale' ? decimalPrecision : 0\n\n  const val = mode === 'min-scale'\n    ? trimDecimalZeros(value)\n    : padZeros(value, precision)\n\n  /**\n   * we do not leave last dot without any digits after -> so we trim it.\n   */\n  return val.replace(/\\.$/, '')\n}\n","import type { ComplementMode, NumberInputProps, NumberInputPreset } from './types'\n\ninterface ModeValues {\n  blurComplementMode: ComplementMode\n  mountComplementMode: ComplementMode\n}\n\ntype Presets = Record<NumberInputPreset, Partial<NumberInputProps>>\n\nexport const PRESETS: Presets = {\n  percent: {\n    startAdornment: '%',\n    isNegativeAllowed: false,\n    min: 0,\n    max: 100,\n    isEmptyAllowed: false,\n    mode: 'decimal'\n  },\n  price: {\n    startAdornment: '$',\n    isNegativeAllowed: false,\n    min: 0,\n    isEmptyAllowed: false,\n    mode: 'decimal'\n  },\n  financial: {\n    startAdornment: '$',\n    isEmptyAllowed: true,\n    mode: 'decimal',\n    blurComplementMode: 'min-scale',\n    mountComplementMode: 'min-scale'\n  }\n}\n\nconst MODE_PROPS: ModeValues = {\n  blurComplementMode: 'max-scale',\n  mountComplementMode: 'max-scale'\n}\n\nconst OTHER_PROPS = {\n  isNegativeAllowed: true,\n  isEmptyAllowed: true,\n  isNumberString: false,\n  isSelectedOnFocus: false,\n  mode: 'integer',\n  thousandSeparator: ','\n}\n\nexport const DEFAULT_PROPS = { ...MODE_PROPS, ...OTHER_PROPS }\n","import type { FocusEvent, ChangeEvent, KeyboardEvent, FC } from 'react'\nimport { useCallback, useRef, useEffect } from 'react'\nimport signedNumbersAndDots from '@utils/formatters/signedNumbersAndDots'\nimport onlyNumbersAndDots from '@utils/formatters/onlyNumbersAndDots'\nimport Input from '../Input'\nimport type { ComplementMode, NumberInputProps } from './types'\nimport {\n  isEmptyString,\n  findNthNumCharIndex,\n  NOT_ALLOWED_NUM_CHARS_REGEX,\n  trimEndingZeros,\n  applyComplement,\n  isInvalidNumberString,\n  trimStartingZeros,\n  getDecimalPartTrimmedWithDot\n} from './utils'\nimport { PRESETS, DEFAULT_PROPS } from './constants'\n\ninterface CharsToEdge {\n  chars: number\n  edge: 'start' | 'end'\n}\n\n/**\n * https://esdiscuss.org/topic/numberformat-maxsignificantdigits-limit\n */\nconst MAGIC_NUMBER = 21\nconst MINUS = '-'\nconst PRECISIONS = { integer: 0, decimal: 2 }\nconst BANNED_KEYS = ['Insert']\n\nconst NumberInput: FC<NumberInputProps> = ({ preset, ...otherProps }) => {\n  const {\n    blurComplementMode,\n    mountComplementMode,\n    isEmptyAllowed,\n    isNumberString,\n    isSelectedOnFocus,\n    mode,\n    min,\n    max,\n    isNegativeAllowed: _isNegativeAllowed,\n    decimalPrecision: _decimalPrecision,\n    onFocus: _onFocus,\n    onChange: _onChange,\n    onBlur: _onBlur,\n    thousandSeparator,\n    value: _value,\n    preset: _preset,\n    ...rest\n  } = { ...DEFAULT_PROPS, ...(preset != null ? PRESETS[preset] : undefined), ...otherProps }\n\n  const decimalPrecision = _decimalPrecision ?? (mode === 'integer'\n    ? PRECISIONS.integer\n    : PRECISIONS.decimal)\n\n  const isNegativeAllowed = (min ?? 0) < 0 ? true : _isNegativeAllowed\n\n  /**\n   * input element ref\n   */\n  const refInput = useRef<HTMLInputElement>(null)\n  /**\n   * stores information about stable chars length to the edge in onKeyDown.\n   * Stable chars are: 0-9.- - so those which are valid for number.\n   */\n  const refCharsInfo = useRef<CharsToEdge>({ chars: 0, edge: 'end' })\n\n  /**\n   * used to track prev input value (which contains all the formatting)\n   */\n  const refPrevInputVal = useRef<string | null>(null)\n\n  /**\n   * used to track if onChange just happend. We want to format each new value we receive.\n   * But we do formatting in onChange because there we manage input value and cursor.\n   *\n   * So we listen to value changes but format them only if this change was not after onChange.\n   * This ref is reset in onBlur and in value updates listening effect.\n   */\n  const refChanged = useRef(false)\n\n  /**\n   * param @complementMode - used only for internal formatting. Not used for change event.\n   */\n  const formatValue = useCallback((value?: string | number | null, complementMode?: ComplementMode): string => {\n    /**\n     * we allow empty input while it is in work disregarding isEmptyAllowed option.\n     * isEmptyAllowed controls what value will be after onBlur event and during onMount event.\n     *\n     * If we pass complementMode it means we format value for view and not for Change\n     * This means that we need to allow the whole formatting pipe to go through\n     */\n    if ((value === '' || value == null) && complementMode == null) {\n      return ''\n    }\n\n    if (value === MINUS && isNegativeAllowed) {\n      return MINUS\n    }\n\n    const valueStr = (value ?? '').toString()\n    let formattedValue = thousandSeparator != null\n      ? valueStr.replace(new RegExp(thousandSeparator, 'g'), '')\n      : valueStr\n\n    if (isNaN(Number(formattedValue))) {\n      return refPrevInputVal.current ?? ''\n    }\n\n    if (isEmptyAllowed && isEmptyString(formattedValue)) {\n      return ''\n    }\n\n    if (!isNegativeAllowed) {\n      formattedValue = onlyNumbersAndDots(formattedValue) ?? ''\n    }\n\n    formattedValue = trimEndingZeros(formattedValue)\n    const numValue = Number(formattedValue)\n\n    if (min != null && (typeof min === 'number' ? numValue < min : numValue < min(numValue))) {\n      const _min = typeof min === 'number' ? min : min(numValue)\n      formattedValue = `${_min}`\n    }\n\n    if (max != null && (typeof max === 'number' ? numValue > max : numValue > max(numValue))) {\n      const _max = typeof max === 'number' ? max : max(numValue)\n      formattedValue = `${_max}`\n    }\n\n    const integerPart = trimStartingZeros(formattedValue.split('.')[0] ?? '')\n    let decimalPart = ''\n\n    if (decimalPrecision > 0 && formattedValue.includes('.')) {\n      decimalPart = getDecimalPartTrimmedWithDot(formattedValue, decimalPrecision)\n    }\n\n    const integerPartFormatted = thousandSeparator != null\n      ? integerPart.replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandSeparator)\n      : integerPart\n\n    let res = `${integerPartFormatted}${decimalPart}`\n\n    if (complementMode != null) {\n      res = applyComplement(res, complementMode, decimalPrecision)\n    }\n\n    return res\n  }, [\n    isNegativeAllowed, isEmptyAllowed, decimalPrecision, min, max, thousandSeparator\n  ])\n\n  /**\n   * used to reduce denendencies\n   */\n  const refFormatValue = useRef(formatValue)\n\n  // ========================================== //\n  //                   HANDLERS                 //\n  // ========================================== //\n\n  const onChange = useCallback((e: ChangeEvent<HTMLInputElement>): void => {\n    const inputEl = refInput.current\n\n    if (inputEl == null) {\n      return\n    }\n\n    let inputValue = e.target.value.replace(NOT_ALLOWED_NUM_CHARS_REGEX, '')\n\n    /**\n     * edge case -> starting typing from '.'\n     */\n    if (inputValue === '.') {\n      inputEl.value = '0.'\n      inputEl.setSelectionRange(2, 2)\n      return\n    }\n\n    inputValue = refFormatValue.current(inputValue)\n\n    const { chars, edge } = refCharsInfo.current\n    let nextPosition = 0\n\n    /**\n     * DD-NOTE:\n     * we may refactor this to use the same approach -> count nth stable chars from any edge.\n     * Historicly 'end' edge was done first and it allows simplified calculation.\n     */\n    if (edge === 'end') {\n      nextPosition = Math.max(0, inputValue.length - chars)\n    } else {\n      /**\n       * Restore nth stable char from the start edge\n       */\n      const nthDigitIndex = findNthNumCharIndex(inputValue, chars)\n      nextPosition = nthDigitIndex + 1\n    }\n\n    /**\n     * value is of a Primitive type so, onChange does not neccesserily cause rerender\n     * where value is correctly formatted. So we do it directly here and before setting next cursor position\n     */\n    inputEl.value = inputValue\n\n    /**\n     * onChange is not a very good place to set cursor position as it has more async nature.\n     * It seems to be working thought. The best place is onKeyDown.\n     * It would be more reliable to do the most of the logic there.\n     */\n    inputEl.setSelectionRange(nextPosition, nextPosition)\n\n    const unformattedValue = signedNumbersAndDots(inputValue) ?? ''\n\n    const val = isNumberString\n      ? unformattedValue\n      : (isInvalidNumberString(unformattedValue) ? null : Number(unformattedValue))\n\n    refChanged.current = true\n    _onChange(e.target.getAttribute('id') ?? '', val as any)\n  }, [_onChange, isNumberString])\n\n  const onKeyDown = useCallback((e: KeyboardEvent<HTMLInputElement>): void => {\n    if (refInput.current == null) {\n      return\n    }\n\n    const val = refInput.current.value\n    const cursorStart = refInput.current.selectionStart ?? 0\n    const cursorEnd = refInput.current.selectionEnd ?? 0\n\n    /** Typing guards **/\n\n    /**\n     * we do not disallow some specific keys except banned because anyway we can not\n     * protect at this point from copy-pasting illegal to the input.\n     * So, input value is cleared up in onChange.\n     */\n\n    if (BANNED_KEYS.includes(e.key)) {\n      e.preventDefault()\n      return\n    }\n\n    if (e.key === MINUS && !isNegativeAllowed) {\n      e.preventDefault()\n      return\n    }\n\n    if (e.key === '.' && decimalPrecision < 1) {\n      e.preventDefault()\n    }\n\n    /** Typing guards **/\n\n    /**\n     * this is calculated only for the case when text is erased -\n     * that is why it is right before current selectionStart.\n     */\n    const posBeforeCurr = Math.max(0, cursorStart - 1)\n    const isBackspace = e.key === 'Backspace'\n    const isDel = e.key === 'Delete' || e.key === 'Del'\n    const isNotSelection = cursorEnd === cursorStart\n\n    /**\n     * if we erase by one symbol and previous is separator we just move cursor to pass the symbol.\n     * if we have a selection and are going to delete it we must allow that to happen.\n     */\n    if (isBackspace && val[posBeforeCurr] === thousandSeparator && isNotSelection) {\n      e.preventDefault()\n      refInput.current.setSelectionRange(posBeforeCurr, posBeforeCurr)\n      return\n    }\n\n    /**\n     * cursor is before comma but as cursor shares the same starting from 0 positioning it means\n     * their indexes are the same.\n     */\n    if (isDel && val[cursorStart] === thousandSeparator && isNotSelection) {\n      e.preventDefault()\n      refInput.current.setSelectionRange(cursorStart + 1, cursorStart + 1)\n      return\n    }\n\n    if (isDel) {\n      /**\n       * in case we delete to the right we need to count chars from start and dock the cursor relative to it.\n       * for deletion to the right we count only stable chars, disregarding unstable formatting chars.\n       */\n      refCharsInfo.current = {\n        chars: val.slice(0, cursorStart).replace(NOT_ALLOWED_NUM_CHARS_REGEX, '').length,\n        edge: 'start'\n      }\n    } else {\n      /**\n       * Edge case: when you delete by one char each time and previous symbol is MINUS\n       * but next symbol is separator -> we need to compensate one char position loss\n       * because basicaly 2 chars would be removed at once (current digit and separator following it).\n       * We do it to preserve cursor after MINUS sign.\n       */\n      const posBeforePrev = Math.max(0, posBeforeCurr - 1)\n      let cursorCorrection = (isBackspace && val[posBeforePrev] === MINUS && val[cursorEnd] === thousandSeparator)\n        ? 1\n        : 0\n\n      /**\n       * Edge case for improved UX: if current key is '.' and it is from any side near a separator\n       * we make a cursor correction\n       * +2 if separator is ahead as we remove separator and also want to be after '.'\n       * +1 if separator is behind as we remove separator but are already ahead of '.'\n       */\n      if (e.key === '.') {\n        cursorCorrection += (val[cursorEnd] === thousandSeparator\n          ? 2\n          : val[posBeforeCurr] === thousandSeparator\n            ? 1\n            : 0)\n      }\n\n      /**\n       * Edge case for improved UX: if user is after dot and is changing decimal part\n       * we allow that and move cursor if there was no selection.\n       */\n      const dotIdx = val.indexOf('.')\n      if (dotIdx > -1 && cursorEnd > dotIdx && /\\d/.test(e.key) && isNotSelection) {\n        cursorCorrection += 1\n      }\n\n      /**\n       * for cursor preservation we need current selectionEnd which would give correct position\n       * in case text is selected or not. This is used as the place for the cursor after the following onChange event.\n       *\n       * We subtract cursorEnd and correction because we position cursor relative to the chars to end.\n       * So, less value -> closer it is to the end.\n       */\n\n      refCharsInfo.current = {\n        chars: Math.max(val.length - cursorEnd - cursorCorrection, 0),\n        edge: 'end'\n      }\n    }\n\n    refPrevInputVal.current = val\n  }, [isNegativeAllowed, decimalPrecision, thousandSeparator])\n\n  const onBlur = useCallback((e: FocusEvent<HTMLInputElement>) => {\n    if (refInput.current == null) {\n      return\n    }\n\n    refChanged.current = false\n    let val = refInput.current.value\n\n    if (isEmptyAllowed && isEmptyString(val)) {\n      refPrevInputVal.current = val\n      _onBlur?.(e)\n      return\n    }\n\n    val = isEmptyString(val) ? '0' : val\n\n    if (val.startsWith('.')) {\n      val = `0${val}`\n    }\n\n    val = applyComplement(val, blurComplementMode, decimalPrecision)\n    refPrevInputVal.current = val\n\n    /**\n     * onBlur we only want input to show formatted value.\n     * It is important to set target.value as well to keep possible event handlers chains in sync with the value.\n     */\n    e.target.value = val\n    refInput.current.value = val\n\n    _onBlur?.(e)\n  }, [_onBlur, blurComplementMode, decimalPrecision, isEmptyAllowed])\n\n  const onFocus = useCallback((e: FocusEvent<HTMLInputElement>) => {\n    _onFocus?.(e)\n\n    if (isSelectedOnFocus) {\n      e?.target?.select()\n    }\n  }, [_onFocus, isSelectedOnFocus])\n\n  // ========================================== //\n  //                   EFFECTS                  //\n  // ========================================== //\n\n  useEffect(() => {\n    refFormatValue.current = formatValue\n  }, [formatValue])\n\n  useEffect(() => {\n    if (refInput.current == null) {\n      return\n    }\n\n    if (refChanged.current) {\n      refChanged.current = false\n      return\n    }\n\n    refInput.current.value = refFormatValue.current(_value, mountComplementMode)\n    refPrevInputVal.current = refInput.current.value\n  }, [_value, decimalPrecision, mountComplementMode])\n\n  return (\n    <Input\n      inputRef={refInput}\n      type='text'\n      /**\n       * as we modify value in place and pass only defaultValue we need it to be formatted.\n       * Reminder - we modify value in place because we manage cursor position and for this we can\n       * not wait for state updates.\n       */\n      defaultValue={formatValue(_value, mountComplementMode)}\n      onChange={onChange}\n      onFocus={onFocus}\n      onKeyDown={onKeyDown}\n      onBlur={onBlur}\n      maxLength={MAGIC_NUMBER}\n      {...rest}\n    />\n  )\n}\n\nexport default NumberInput\n"],"names":["NOT_ALLOWED_NUM_CHARS_REGEX","complementMinusOrEmpty","__name","val","trimDecimalZeros","integerPart","decimalPart","padZeros","decimalPrecision","zerosToAdd","findNthNumCharIndex","n","digitCount","i","isEmptyString","isInvalidNumberString","trimEndingZeros","value","trimStartingZeros","getDecimalPartTrimmedWithDot","dotPart","trimmedDecimals","applyComplement","mode","PRESETS","MODE_PROPS","OTHER_PROPS","DEFAULT_PROPS","MAGIC_NUMBER","MINUS","PRECISIONS","BANNED_KEYS","NumberInput","preset","blurComplementMode","mountComplementMode","isEmptyAllowed","isNumberString","isSelectedOnFocus","min","max","_isNegativeAllowed","_decimalPrecision","_onFocus","_onChange","_onBlur","thousandSeparator","_value","_preset","rest","undefined","otherProps","isNegativeAllowed","refInput","useRef","refCharsInfo","refPrevInputVal","refChanged","formatValue","useCallback","complementMode","valueStr","formattedValue","numValue","res","refFormatValue","onChange","e","inputEl","inputValue","chars","edge","nextPosition","unformattedValue","signedNumbersAndDots","onKeyDown","cursorStart","cursorEnd","posBeforeCurr","isBackspace","isDel","isNotSelection","length","posBeforePrev","cursorCorrection","dotIdx","onBlur","onFocus","useEffect","_jsx","Input"],"mappings":"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"}